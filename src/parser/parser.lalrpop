use std::str::FromStr;
use crate::parser::ast::{Type, Expr, Opcode, Statement};

grammar;

pub Program: Vec<Statement> = <Statement+> => <>;

pub Statement: Statement = {
    <l: @L> <le:Let> <r: @R> => Statement::Let(le.0, le.1, le.2, le.3, l, r),
    <l: @L> <le:Reassign> <r: @R> => Statement::Reassign(le.0, le.1, l, r),
    <l: @L> <f:Function> <r: @R> => Statement::Function(f.0, f.1, f.2, f.3, l, r),
    <l: @L> <f:Macro> <r: @R> => Statement::Macro(f.0, f.1, f.2, f.3, l, r),
    <l: @L> <ret:Return> <r: @R> => Statement::Return(ret, l, r),
    <l: @L> <i:If> <r: @R> => Statement::If(i.0, i.1, l, r),
    <l: @L> <exp:BoxedExpr> ";" <r: @R> => Statement::Expression(exp, l, r),
}

pub Expr: Expr = {
    <l: @L> <exp:Expr> <op:BoolOp> <boolexp:BoolExpr> <r: @R> => Expr::Op(Box::new(exp), op, Box::new(boolexp), l, r),
    BoolExpr,
}

pub BoxedExpr: Box<Expr> = Expr => Box::new(<>);

pub BoolExpr: Expr = {
    <l: @L> <exp:BoolExpr> <op:CondOp> <arit:ArithmeticExpr> <r: @R> => Expr::Op(Box::new(exp), op, Box::new(arit), l, r),
    ArithmeticExpr,
}

pub ArithmeticExpr: Expr = {
    <l: @L> <exp:ArithmeticExpr> <op:ExprOp> <f:Factor> <r: @R> => Expr::Op(Box::new(exp), op, Box::new(f), l, r),
    Factor,
}

ExprOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

Factor: Expr = {
    <l: @L> <f:Factor> <op:FactorOp> <t:Term> <r: @R> => Expr::Op(Box::new(f), op, Box::new(t), l, r),
    Term,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
    "%" => Opcode::Rem,
}

CondOp: Opcode = {
    "==" => Opcode::Eq,
    "!=" => Opcode::NotEq,
    "<" => Opcode::LessThan,
    ">" => Opcode::GreaterThan,
    "<=" => Opcode::LessEqual,
    ">=" => Opcode::GreaterEqual,
}

BoolOp: Opcode = {
    "||" => Opcode::Or,
    "&&" => Opcode::And,
}

Term: Expr = {
    <l: @L> <s:StringVal> <r: @R> => Expr::String(s, l, r),
    <l: @L> <n:Num> <r: @R> => Expr::Number(n, l, r),
    <l: @L> <b:Bool> <r: @R> => Expr::Boolean(b, l, r),
    <l: @L> <i:Identifier> <r: @R> => Expr::Identifier(i, l, r),
    <l: @L> <f:FunctionCall> <r: @R> => Expr::FunctionCall(f.0, f.1, l, r),
    <l: @L> <f:ArrayLiteral> <r: @R> => Expr::ArrayLiteral(f, l, r),
    <l: @L> <f:ArrayIndex> <r: @R> => Expr::ArrayIndex(Box::new(f.0), Box::new(f.1), l, r),
    "(" <Expr> ")",
};

AzulaType: Type = {
    "int" => Type::Integer(32),
    "int32" => Type::Integer(32),
    "int64" => Type::Integer(64),
    "float" => Type::Float(32),
    "float32" => Type::Float(32),
    "float64" => Type::Float(64),
    "string" => Type::String,
    "bool" => Type::Boolean,
    "T" => Type::Generic(0),
    "array[" <AzulaType> "]" => Type::Array(Box::new(<>)),
}

Mutability: String = {
    "mut" => <>.to_string()
}

Identifier: String = {
    r"[a-zA-Z_]+" => <>.to_string()
}

TypedIdentifier: (Type, String) = {
    <i:Identifier> ":" <t:AzulaType> => (t, i.to_string()),
}

Let: (Option<String>, String, Option<Type>, Box<Expr>) = {
    "let" <Mutability?> <Identifier> <TypeAnnotation?> "=" <BoxedExpr> ";"
}

Reassign: (String, Box<Expr>) = {
    <Identifier> "=" <BoxedExpr> ";"
}

TypeAnnotation: Type = {
    ":" <AzulaType>
}

Function: (String, Option<Vec<(Type, String)>>, Option<Type>, Vec<Statement>) = {
    "func" <Identifier> <Paren<Comma<TypedIdentifier>>?> <ReturnType?> <Brace<Statement*>>
}

Macro: (String, Option<Vec<(Type, String)>>, Option<Type>, Vec<Statement>) = {
    "macro" <Identifier> <Paren<Comma<TypedIdentifier>>?> <ReturnType?> <Brace<Statement*>>
}

FunctionCall: (String, Vec<Expr>) = {
    <Identifier> <Paren<Comma<Expr>>>
}

FunctionCallStmt: (String, Vec<Expr>) = {
    <Identifier> <Paren<Comma<Expr>>> ";"
}

ReturnType: Type = ":" <AzulaType> => <>; 

Return: Option<Box<Expr>> = {
    "return" <BoxedExpr?> ";"
}

Num: f64 = r"[0-9]+(.[0-9]+)?" => f64::from_str(<>).unwrap();

StringAllowedVals: String = {
    <r#""[a-zA-Z%&,;:\s\\]*""#> => <>.to_string(),
    <r#"'[a-zA-Z%&,;:\s\\]*'"#> => <>.to_string(),
}

StringVal: String = {
    <st:StringAllowedVals> => st.to_string(),
}

Bool: bool = {
    "true" => true,
    "false" => false,
}

ArrayLiteral: Vec<Expr> = {
    "[" <Comma<Expr>> "]"
}

ArrayIndex: (Expr, Expr) = {
    <Term> "[" <Expr> "]"
}

If: (Box<Expr>, Vec<Statement>) = {
    "if" <BoxedExpr> <Brace<Statement*>>
}

Paren<T> = "(" <T> ")";
Brace<T> = "{" <T> "}";
Bracket<T> = "[" <T> "]";

Comma<T> = Delim<T, ",">;

Delim<T, D>: Vec<T> = {
    <h: (<T> D)*> <t: T?> => match t {
        Some(t) => {
            let mut h = h;
            h.push(t);
            h
        }
        None => h
    }     
};

match {
    r#""[a-zA-Z%&,;:\s\\]*""#,
    r#"'[a-zA-Z%&,;:\s\\]*'"#,
    // r"[a-zA-Z_]+",
    r"//[^\n\r]*[\n\r]*" => { }, // `// comment`
    r"\s*" => { },
    _
}