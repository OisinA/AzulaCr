use std::str::FromStr;
use crate::parser::ast::{Type, Expr, Opcode, Statement};

grammar;

pub Program: Vec<Statement> = <Statement+> => <>;

pub Statement: Statement = {
    Let => Statement::Let(<>.0, <>.1, <>.2),
    Function => Statement::Function(<>.0, <>.1, <>.2, <>.3),
    Return => Statement::Return(<>),
    If => Statement::If(<>.0, <>.1),
    <BoxedExpr> ";" => Statement::Expression(<>),
}

pub Expr: Expr = {
    <exp:Expr> <op:BoolOp> <boolexp:BoolExpr> => Expr::Op(Box::new(exp), op, Box::new(boolexp)),
    BoolExpr,
}

pub BoxedExpr: Box<Expr> = Expr => Box::new(<>);

pub BoolExpr: Expr = {
    <exp:BoolExpr> <op:CondOp> <arit:ArithmeticExpr> => Expr::Op(Box::new(exp), op, Box::new(arit)),
    ArithmeticExpr,
}

pub ArithmeticExpr: Expr = {
    <exp:ArithmeticExpr> <op:ExprOp> <f:Factor> => Expr::Op(Box::new(exp), op, Box::new(f)),
    Factor,
}

ExprOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

Factor: Expr = {
    <f:Factor> <op:FactorOp> <t:Term> => Expr::Op(Box::new(f), op, Box::new(t)),
    Term,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
    "%" => Opcode::Rem,
}

CondOp: Opcode = {
    "==" => Opcode::Eq,
    "!=" => Opcode::NotEq,
    "<" => Opcode::LessThan,
    ">" => Opcode::GreaterThan,
    "<=" => Opcode::LessEqual,
    ">=" => Opcode::GreaterEqual,
}

BoolOp: Opcode = {
    "||" => Opcode::Or,
    "&&" => Opcode::And,
}

Term: Expr = {
    StringVal => Expr::String(<>),
    Num => Expr::Number(<>),
    Bool => Expr::Boolean(<>),
    Identifier => Expr::Identifier(<>),
    FunctionCall => Expr::FunctionCall(<>.0, <>.1),
    "(" <Expr> ")",
};

AzulaType: Type = {
    "int" => Type::Integer(32),
    "int32" => Type::Integer(32),
    "int64" => Type::Integer(64),
    "float" => Type::Float(32),
    "float32" => Type::Float(32),
    "float64" => Type::Float(64),
    "string" => Type::String,
    "bool" => Type::Boolean,
}

Mutability: String = {
    "mut" => <>.to_string()
}

Identifier: String = {
    r"[a-zA-Z_]+" => <>.to_string()
}

TypedIdentifier: (Type, String) = {
    <AzulaType> <Identifier>
}

Let: (Option<String>, String, Box<Expr>) = {
    "let" <Mutability?> <Identifier> "=" <BoxedExpr> ";"
}

Function: (String, Option<Vec<(Type, String)>>, Option<Type>, Vec<Statement>) = {
    "func" <Identifier> <Paren<Comma<TypedIdentifier>>?> <ReturnType?> <Brace<Statement*>>
}

FunctionCall: (String, Vec<Expr>) = {
    <Identifier> <Paren<Comma<Expr>>>
}

FunctionCallStmt: (String, Vec<Expr>) = {
    <Identifier> <Paren<Comma<Expr>>> ";"
}

ReturnType: Type = ":" <AzulaType> => <>; 

Return: Option<Box<Expr>> = {
    "return" <BoxedExpr?> ";"
}

Num: f64 = r"[0-9]+(.[0-9]+)?" => f64::from_str(<>).unwrap();

StringAllowedVals: String = {
    r"[a-zA-Z_]+" => <>.to_string(),
    Bool => <>.to_string(),
}

StringVal: String = {
    r"'" <StringAllowedVals+> r"'" => <>.join(" "),
    r#"""# <StringAllowedVals+> r#"""# => <>.join(" "),
}

Bool: bool = {
    "true" => true,
    "false" => false,
}

If: (Box<Expr>, Vec<Statement>) = {
    "if" <BoxedExpr> <Brace<Statement*>>
}

Paren<T> = "(" <T> ")";
Brace<T> = "{" <T> "}";
Bracket<T> = "[" <T> "]";

Comma<T> = Delim<T, ",">;

Delim<T, D>: Vec<T> = {
    <h: (<T> D)*> <t: T?> => match t {
        Some(t) => {
            let mut h = h;
            h.push(t);
            h
        }
        None => h
    }     
};